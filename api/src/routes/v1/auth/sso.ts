import { Controller, Inject } from "@tsed/di";
import { Get, Post } from "@tsed/schema";
import { SessionService } from "@services/SessionService";
import { Context, Next, Req, Res, Use, UseBefore } from "@tsed/common";
import { LoggerService } from "@services/LoggerService";
import saml from "samlp";
import fs from "fs";
import path from "path";
import { cwd } from "process";
import { SessionMiddleware } from "@middlewares/session.middleware";
import { Config } from "@config";
import { SessionParticipants } from "@utils";
import crypto from "crypto";

@Controller("/auth/sso")
export class AuthSSORoute {

  public logger = this.loggerService.child({
    label: {
      name: "Auth Endpoint",
      type: "auth",
    },
  });

  constructor(
    @Inject() private loggerService: LoggerService
  ) {

  }

  @Get("/saml")
  @UseBefore(SessionMiddleware)
  public async getSSOSaml(
    @Req() request: Req,
    @Res() response: Res,
    @Next() next: Next,
    @Context("session") session: SessionService
  ) {

    let currentSessionIndex = '0';

    if(session.getUser.logged) {
      if(session.getSsoByNameId(session.getUser.username)) {
        currentSessionIndex = session.getSsoByNameId(session.getUser.username).sessionIndex;
      } else {
        const newSession = session.addSSO({
          serviceProviderId : 'rutsukun-sso', // The Issuer (Session Participant id)
          nameId: session.getUser.username, // NameId Of the logged in user in the SP
          nameIdFormat: 'urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified', // Format of the NameId
          sessionIndex: await crypto.randomBytes(18).toString("hex"), // The session index generated by the IdP
          serviceProviderLogoutURL: 'http://localhost:8080/auth/realms/master/broker/saml/endpoint', // The logout URL of the Session Participant
        })

        currentSessionIndex = newSession.sessionIndex;

        await session.saveSession();
      }
    } else {
      return response.redirect(Config.FRONTEND.url + `/signin?sso=${Buffer.from(request.originalUrl).toString('base64')}`);
    }

    saml.auth({
        issuer: "account-console-saml",
        cert: fs.readFileSync(path.join(cwd(), "src", "config", "keys", "saml-cert.crt")),
        key: fs.readFileSync(path.join(cwd(), "src", "config", "keys", "saml-private-key.key")),
        destination: "http://localhost:8080/auth/realms/master/broker/saml/endpoint",
        // @ts-ignore
        sessionIndex: currentSessionIndex,
        signResponse: true,
        store: null,
        getPostURL: (wtrealm, wreply, req, callback) => {
            console.log('wtrealm', wtrealm);
            
            return callback( null, 'http://localhost:8080/auth/realms/master/broker/saml/endpoint')
        }
      })(request, response, next)
  }

  @Post("/saml")
  @UseBefore(SessionMiddleware)
  public async postSSOSaml(
    @Req() request: Req,
    @Res() response: Res,
    @Next() next: Next,
    @Context("session") session: SessionService
  ) {

    let currentSessionIndex = '0';

    if(session.getUser.logged) {
      if(session.getSsoByNameId(session.getUser.username)) {
        currentSessionIndex = session.getSsoByNameId(session.getUser.username).sessionIndex;
      } else {
        const newSession = session.addSSO({
          serviceProviderId : 'rutsukun-sso', // The Issuer (Session Participant id)
          nameId: session.getUser.username, // NameId Of the logged in user in the SP
          nameIdFormat: 'urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified', // Format of the NameId
          sessionIndex: await crypto.randomBytes(18).toString("hex"), // The session index generated by the IdP
          serviceProviderLogoutURL: 'http://localhost:8080/auth/realms/master/broker/saml/endpoint', // The logout URL of the Session Participant
        })

        currentSessionIndex = newSession.sessionIndex;

        await session.saveSession();
      }
    } else {
      return response.redirect(Config.FRONTEND.url + `/signin?sso=${Buffer.from(request.originalUrl).toString('base64')}`);
    }

    saml.auth({
        issuer: "rutsukun-sso",
        cert: fs.readFileSync(path.join(cwd(), "src", "config", "keys", "saml-cert.crt")),
        key: fs.readFileSync(path.join(cwd(), "src", "config", "keys", "saml-private-key.key")),
        destination: "http://localhost:8080/auth/realms/master/broker/saml/endpoint",
        // @ts-ignore
        sessionIndex: '1',
        signResponse: true,
        getPostURL: (wtrealm, wreply, req, callback) => {
            return callback( null, 'http://localhost:8080/auth/realms/master/broker/saml/endpoint')
        }
      })(request, response, next)
  }

  @Get('/saml/metadata')
  public getSSOSamlMetadata(@Req() request: Req, @Res() response: Res, @Next() next: Next) {
    saml.metadata({
        issuer: "rutsukun-sso",
        cert: fs.readFileSync(path.join(cwd(), "src", "config", "keys", "saml-cert.crt")),
        // @ts-ignore
        key: fs.readFileSync(path.join(cwd(), "src", "config", "keys", "saml-private-key.key")),
        redirectEndpointPath: `${Config.OAUTH2.issuer}/v1/auth/sso/saml`,
        postEndpointPath: `${Config.OAUTH2.issuer}/v1/auth/sso/saml`,
        logoutEndpointPaths: {
            redirect: `${Config.OAUTH2.issuer}/v1/auth/sso/logout`,
            post: `${Config.OAUTH2.issuer}/v1/auth/sso/logout`
        }
    })(request, response, next)
  }

  // @Post('/logout')
  // @Use(cors())
  // @Use(SessionMiddleware)
  // public postSSOLogout(
  //   @Req() request: Req,
  //   @Res() response: Res,
  //   @Next() next: Next,
  //   @Context("session") session: SessionService
  // ) {

  //   const sessions = new SessionParticipants(session.getSso.map((sso)=>{
  //     return {
  //       ...sso,
  //       cert: fs.readFileSync(path.join(cwd(), "src", "config", "keys", "saml", "sp-public-key.pem")) // The Session Participant public certificate, used to verify the signature of the SAML requests made by this SP
  //     }
  //   }))
    
  //   saml.logout({
  //       issuer: "rutsukun-sso",
  //       cert: fs.readFileSync(path.join(cwd(), "src", "config", "keys", "saml-cert.crt")),
  //       key: fs.readFileSync(path.join(cwd(), "src", "config", "keys", "saml-private-key.key")),
  //       // @ts-ignore
  //       sessionParticipants: sessions,
  //       store: null,
  //       getPostURL: (audience, authnRequestDom, req, callback) => {
  //         console.log('audience', audience);
  //         console.log('authnRequestDom', authnRequestDom);
        
  //         return callback( null, 'http://localhost:8080/auth/realms/master/broker/saml/endpoint')
  //     }
  //   })(request, response, next)
  // }

  @Get('/logout')
  @Use(SessionMiddleware)
  public async getSSOLogout(
    @Req() request: Req,
    @Res() response: Res,
    @Next() next: Next,
    @Context("session") session: SessionService
  ) {

    const sessions = new SessionParticipants(session.getSso.map((sso)=>{
      return {
        ...sso,
        cert: fs.readFileSync(path.join(cwd(), "src", "config", "keys", "saml", "sp-public-key.pem")) // The Session Participant public certificate, used to verify the signature of the SAML requests made by this SP
      }
    }))

    session.deleteSso(session.getUser.username, 'rutsukun-sso');
    await session.saveSession();
    
    saml.logout({
        issuer: "rutsukun-sso",
        cert: fs.readFileSync(path.join(cwd(), "src", "config", "keys", "saml-cert.crt")),
        key: fs.readFileSync(path.join(cwd(), "src", "config", "keys", "saml-private-key.key")),
        // @ts-ignore
        sessionParticipants: sessions,
        store: null,
        getPostURL: (audience, authnRequestDom, req, callback) => {
          console.log('audience', audience);
          console.log('authnRequestDom', authnRequestDom);
        
          return callback( null, 'http://localhost:8080/auth/realms/master/broker/saml/endpoint')
      }
    })(request, response, next)
  }

}
